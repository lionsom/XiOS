# 二、位运算基本概念
[知乎-在写代码的过程中使用位运算的好处？](https://www.zhihu.com/question/34021773)
[九章 - 干货！史上最强位运算面试题大总结！](https://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&mid=2649456688&idx=1&sn=467f105e3306a47b5b4768d12d7f6fe7&chksm=887eee38bf09672ec7725ac7edac6f8e3801a1c1cfcb072c16dda99b36d21bcdc9cb08fef8c7&mpshare=1&scene=1&srcid=0317fQV1z43SxmGxHAuVKZWv&key=32ff7e6b073562f9d3e5c6a75b00a1e44ef11b1f30bb189e6e6cac5dbe218b1c0cbfff9d9766ee1fafb419fff7e5dfcc9cf3b892a88a76935043aa6861379c6d572ad08119cbcf3a19bc6da910f843a7&ascene=0&uin=MTUyMzg3NjAwMA%3D%3D&devicetype=iMac+MacBookAir7%2C1+OSX+OSX+10.12.3+build(16D32)&version=12020010&nettype=WIFI&fontScale=100&pass_ticket=0AiIToHJN8yqpuqRAsA5PaaQMJr8KtvlnZ2EqkX0zx%2BEZweRvHKyF%2ByjmycpUbVn)
[九章 - 位运算入门教程](https://www.jiuzhang.com/tutorial/bit-manipulation/74)


####2.1、左移操作 a << b
>将A的二进制表示的每一位向左移B位，左边超出的位截掉，右边不足的位补0
```
A = 1100  B = 2
A << B = 110000
```

####2.2、右移操作 A >> B , A >>> B
>右移操作分为 ***算数右移*** 和 ***逻辑右移*** 
>区别：***算术右移***是带符号的右移，***逻辑右移***是不带符号的右移。
>算术右移：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补符号位的数。
>逻辑右移：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补0。
>C语言：只有逻辑右移 A >> B
```
JAVA 和 Python中：算术右移 A >> B , 逻辑右移 A >>> B
A = 11111111111111111111111110000001
B = 2
A >> B = 11111111111111111111111111100000
A >>> B = 00111111111111111111111111100000
```

####2.3、按位与操作 a & b
>将A和B的二进制表示的每一位进行与操作，只有两个对应的二进制位都为1时，结果位才为1，否则为0.
```
A = 001010
B = 101100
A & B = 001000
```

####2.4、按位或操作 a | b
>将A和B的二进制表示的每一位进行或操作，只要两个对应的二进制位有一个为1，结果位就为1，否则为0.
```
A = 001010
B = 101100
A | B = 101110
```

####2.5、按位非操作 ~ a
>将A的二进制表示每一位进行取反操作，如果对应的二进制位为0，结果位为1，否则为0.
``` 
A = 00000000000000000000000000001010
~A = 11111111111111111111111111110101
```

####2.6、按位异或操作 a ^ b
>将A和B的二进制表示的每一位进行异或操作，如果对应的二进制位不同，结果位为1，否则为0.
```
A = 001010
B = 101100
A ^ B = 100110
```


# 三、位运算应用总结
>#### 清零取反要用与，某位置一可用或 
>#### 若要取反和交换，轻轻松松用异或 

####**前提** ：源操作数s       掩码mask
##### 3.1、按位与 & 
* **清零特定位** (mask中特定位置0，其它位为1，s=s&mask) 
```
s = 1010     第二位清0

8 = 10 & 13
1000  =  1010 & 1101
```

* 取某数中指定位 (mask中特定位置1，其它位为0，s=s&mask) 
```
s = 1010     取第二位 和 第三位

2 = 10 & 2
0010 = 1010 & 0010        // 同为1时，则为1。故此第二位为1

0 = 10 & 4
0000 = 1010 & 0100         // 同上。故此第三位为0
```

##### 3.2、按位或 | 
* 常用来将源操作数某些位置1，其它位不变。 (mask中特定位置1，其它位为0 s=s|mask) 
```
s = 1010      将第三位置为1

14 = 10 | 4
1110 = 1010 | 0100      // 只有一个为1，就为1
```

##### 3.3、位异或 ^ 
* 使特定位的值取反 (mask中特定位置1，其它位为0 s=s^mask) 

```
s = 1010      将第二位取反

8 = 10 ^ 2
1000 = 1010 ^ 0010      // 不同为1 ，相同为0
```

* 不引入第三变量，交换两个变量的值 (设 a=a1,b=b1) 

```
int a=10,b=12;   
a=a^b; 
b=a^b; 
a=a^b;  

a = 1010      b=1100
a = a ^ b = 1010 ^ 1100;       // a = 0110
b = a ^ b = 0110 ^ 1100;       // b = 1010
a = a ^ b = 0110 ^ 1010;       // a = 1100
```
此算法能够实现是由异或运算的特点决定的，通过异或运算能够使数据中的某些位翻转，其他位不变。这就意味着 **任意一个数与任意一个给定的值连续`异或`两次，值不变**。


#### 二进制补码运算公式

```
-x = ~x + 1 = ~(x-1) 
~x = -x-1 
-(~x) = x+1 
~(-x) = x-1 
x+y = x - ~y - 1 = (x|y)+(x&y) 
x-y = x + ~y + 1 = (x|~y)-(~x&y) 
x^y = (x|y)-(x&y) 
x|y = (x&~y)+y 
x&y = (~x|y)-~x 
x==y:    ~(x-y|y-x) 
x!=y:    x-y|y-x 
x < y:    (x-y)^((x^y)&((x-y)^x)) 
x <=y:    (x|~y)&((x^y)|~(y-x)) 
x < y:    (~x&y)|((~x|y)&(x-y))//无符号x,y比较 
x <=y:    (~x|y)&((x^y)|~(y-x))//无符号x,y比较 
```


# 四、位运算实战

[优秀程序员不得不知道的20个位运算技巧](https://blog.csdn.net/zmazon/article/details/8262185#t0)

* 电脑大小端

```
public static byte[] intToByteArray(int a)
{
    byte[] ret = new byte[4];
    ret[3] = (byte) (a & 0xFF);   
    ret[2] = (byte) ((a >> 8) & 0xFF);   
    ret[1] = (byte) ((a >> 16) & 0xFF);   
    ret[0] = (byte) ((a >> 24) & 0xFF);
    return ret;
}
```

* 位运算代替乘除法，提高运算速度
[位运算实现加、减、乘、除运算](https://www.jianshu.com/p/7bba031b11e7)
[用位运算来代替乘法、除法以及取模](http://blog.csdn.net/wusecaiyun/article/details/46552585)
```
假设有两个数，A和B。B为2^n，期中n>=0，A>=0。则：
要求A * B的话，则可使用<<操作符，A << n。
要求A / B的话，则可使用>>操作符，A >> n。
要求A % B的话，则可使用&操作符，A&(B-1)。

如果A为负数的话，则未必成立。比如，当A为-1，B为2的时候，可知(-1)%2=-1，而-(1)&0=0。
记住，当我们把乘法，除法及取模运算转化为位运算时，都要求A>=0。
```